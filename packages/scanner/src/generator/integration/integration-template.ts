import type {
  ComponentInfo,
  GeneratedTest,
  TestGeneratorOptions,
} from '../../types';
import { basename, dirname, join } from 'path';

const DEFAULT_OPTIONS: TestGeneratorOptions = {
  includeVisibility: false, // Not applicable for integration tests
  includeInteractions: false, // Not applicable for integration tests
  includeNavigation: false, // Not applicable for integration tests
  includeForms: false, // Not applicable for integration tests
  includeA11y: false,
  addTodos: true,
};

/**
 * Generate integration test file using @ux.qa/frontmock
 *
 * Integration tests focus on:
 * - Component with API calls
 * - Component with hooks
 * - Component with complex state
 * - Component with providers/context
 */
export function generateIntegrationTest(
  component: ComponentInfo,
  options: Partial<TestGeneratorOptions> = {}
): GeneratedTest {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const tests: string[] = [];
  let testCount = 0;

  // Check if component has event handlers (likely has logic to test)
  const hasInteractions = component.elements.some(e => e.handlers.length > 0);
  const hasProps = component.props.length > 0;

  // Generate integration tests based on component characteristics
  if (hasInteractions || hasProps) {
    tests.push(generateComponentIntegrationTest(component, opts.addTodos));
    testCount++;
  }

  // If component has routes, likely has navigation/routing logic
  if (component.routes.length > 0) {
    tests.push(generateRoutingIntegrationTest(component, opts.addTodos));
    testCount++;
  }

  // If component has forms, test form integration
  const hasForms = component.elements.some(e => e.type === 'form');
  if (hasForms) {
    tests.push(generateFormIntegrationTest(component, opts.addTodos));
    testCount++;
  }

  const content = generateFullTestFile(component, tests);
  const fileName = `${toKebabCase(component.name)}.integration.test.tsx`;
  const testDir = dirname(component.filePath).replace('/src/', '/tests/integration/');

  return {
    filePath: join(testDir, fileName),
    content,
    componentName: component.name,
    testCount,
  };
}

function generateFullTestFile(
  component: ComponentInfo,
  tests: string[]
): string {
  // Extract component path for import
  const componentPath = component.filePath
    .replace(/\.(tsx|jsx)$/, '')
    .replace(/^src\//, '../../');

  return `import { t } from '@ux.qa/frontmock';
import { ${component.name} } from '${componentPath}';

const { describe, it, expect, beforeEach, afterEach, vi, render, screen, waitFor, userEvent } = t;

/**
 * Integration tests for ${component.name}
 * Generated by @ux.qa/scanner
 *
 * These tests focus on how the component integrates with:
 * - APIs and data fetching
 * - State management
 * - Routing and navigation
 * - External services
 *
 * Review and customize these tests before committing.
 */
describe('${component.name} - Integration', () => {
  beforeEach(() => {
    // Reset mocks before each test
    vi.clearAllMocks();
  });

  afterEach(() => {
    // Cleanup after each test
    vi.restoreAllMocks();
  });

${tests.join('\n\n')}
});
`;
}

function generateComponentIntegrationTest(component: ComponentInfo, addTodos: boolean): string {
  const todo = addTodos ? '\n\n    // TODO: Add assertions for:\n    // - API calls are made correctly\n    // - Loading states are shown\n    // - Error states are handled\n    // - Data is displayed properly' : '';

  return `  it('integrates with API/services correctly', async () => {
    // Mock API/service calls
    const mockFetch = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => ({ data: 'test data' }),
    });
    global.fetch = mockFetch;

    render(<${component.name} />);

    // Wait for async operations
    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalled();
    });${todo}
  });`;
}

function generateRoutingIntegrationTest(component: ComponentInfo, addTodos: boolean): string {
  const route = component.routes[0] || '/';
  const todo = addTodos ? '\n\n    // TODO: Add assertions for:\n    // - Navigation triggers correctly\n    // - Route params are handled\n    // - Query strings are processed\n    // - Redirects work as expected' : '';

  return `  it('handles routing and navigation correctly', async () => {
    // Mock router/navigation
    const mockNavigate = vi.fn();

    // If using React Router:
    // vi.mock('react-router-dom', () => ({
    //   ...vi.importActual('react-router-dom'),
    //   useNavigate: () => mockNavigate,
    // }));

    const user = userEvent.setup();
    render(<${component.name} />);

    // Trigger navigation action
    // await user.click(screen.getByRole('link', { name: /navigate/i }));

    // expect(mockNavigate).toHaveBeenCalledWith('${route}');${todo}
  });`;
}

function generateFormIntegrationTest(component: ComponentInfo, addTodos: boolean): string {
  const todo = addTodos ? '\n\n    // TODO: Add assertions for:\n    // - Form validation works\n    // - API submission succeeds\n    // - Success/error messages display\n    // - Form resets after submission' : '';

  return `  it('handles form submission integration', async () => {
    const mockSubmit = vi.fn().mockResolvedValue({ success: true });

    const user = userEvent.setup();
    render(<${component.name} onSubmit={mockSubmit} />);

    // Fill form fields
    // await user.type(screen.getByLabelText(/email/i), 'test@example.com');
    // await user.type(screen.getByLabelText(/password/i), 'password123');

    // Submit form
    const submitButton = screen.getByRole('button', { name: /submit/i });
    await user.click(submitButton);

    // Wait for submission
    await waitFor(() => {
      expect(mockSubmit).toHaveBeenCalled();
    });${todo}
  });`;
}

function toKebabCase(str: string): string {
  return str
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/[\s_]+/g, '-')
    .toLowerCase();
}
